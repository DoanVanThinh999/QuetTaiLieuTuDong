package com.example.bai_tap_lon_thi_cuoi_ky_de_9.phienbanvip.ui;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Typeface;
import android.util.Log;
import android.widget.Toast;


import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import org.opencv.android.Utils;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

public class ScanProcessor {

    // ‚úÖ Gi·ªØ l·∫°i h√†m g·ªëc ƒë·ªÉ t∆∞∆°ng th√≠ch
    public static Bitmap detectAndCrop(Context context, Bitmap bitmap) {
        return detectAndCrop(context, bitmap, false);
    }

    public static List<Bitmap> debugSteps = new ArrayList<>();
    public static Bitmap detectAndCrop(Context context, Bitmap bitmap, boolean retryMode) {
        Mat src = new Mat();
        Utils.bitmapToMat(bitmap, src);

        debugSteps.clear();
        debugSteps.add(bitmap.copy(Bitmap.Config.ARGB_8888, true));

        Imgproc.cvtColor(src, src, Imgproc.COLOR_BGR2GRAY);

        // üìå Blur nh·∫π ho·∫∑c m·∫°nh t√πy theo retryMode
        Imgproc.GaussianBlur(src, src, retryMode ? new Size(11, 11) : new Size(5, 5), 0);

        double median = computeMedian(src);  //Median > 200--> Qu√° ch√≥i, < 40 qu√° t·ªëi
        double lower = Math.max(0, (retryMode ? 0.05 : 0.1) * median); // lower = int(max(0, (1.0 - sigma) * v))
        double upper = Math.min(255, (retryMode ? 1.5 : 1.2) * median); // upper = int(min(255, (1.0 + sigma) * v))
        Log.d("CannyDebug", "=== ·∫¢NH G·ªêC ===");
        Log.d("CannyDebug", "Size: " + bitmap.getWidth() + "x" + bitmap.getHeight());
        Log.d("CannyDebug", "RetryMode: " + retryMode + " | Median: " + median + ", Lower: " + lower + ", Upper: " + upper);


        Mat edge = new Mat();
        Imgproc.Canny(src, edge, lower, upper);

        Mat kernel = Imgproc.getStructuringElement(
                Imgproc.MORPH_RECT,
                retryMode ? new Size(11, 11) : new Size(9, 9)
        );
        Imgproc.morphologyEx(edge, edge, Imgproc.MORPH_CLOSE, kernel);

        Bitmap edgeBmp = Bitmap.createBitmap(edge.cols(), edge.rows(), Bitmap.Config.ARGB_8888);
        Utils.matToBitmap(edge, edgeBmp);
        debugSteps.add(edgeBmp);

        List<MatOfPoint> contours = new ArrayList<>();
        Imgproc.findContours(edge, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
        Log.d("CannyDebug", "=== CONTOUR G·ªêC ===");
        Log.d("CannyDebug", "Contours found: " + contours.size());
        double minArea = (bitmap.getWidth() * bitmap.getHeight()) * (retryMode ? 0.003 : 0.009);
        List<MatOfPoint> filteredContours = new ArrayList<>();
        Log.d("CannyDebug", "Filtered contours1: " + filteredContours.size());
        if (filteredContours.size() == 0 && !retryMode) {
            Log.d("CannyDebugBanDauNeuThua", "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y contour ƒë·ªß l·ªõn ‚Üí Th·ª≠ l·∫°i v·ªõi retryMode = true");

            // Th·ª≠ l·∫°i detect v·ªõi retryMode = true
            Bitmap retried = detectAndCrop(context, bitmap, true);

            if (retried == null) {
                Log.d("CannyDebugError", "‚ùå Retry th·∫•t b·∫°i ‚Äî v·∫´n kh√¥ng t√¨m th·∫•y contour h·ª£p l·ªá.");
            } else {
                Log.d("CannyDebugFIX", "‚úÖ Retry th√†nh c√¥ng ‚Äî ƒë√£ t√¨m th·∫•y contour t√†i li·ªáu!");
            }

            return retried;
        }


        for (MatOfPoint contour : contours) {
            double area = Imgproc.contourArea(contour);
            if (area > minArea) {
                filteredContours.add(contour);
                Log.d("CannyDebug", "Filtered contours2: " + filteredContours.size());

            }
        }


        Log.d("CannyDebug", "=== SAU L·ªåC ===");
        Log.d("CannyDebug", "Filtered contours (> " + (int) minArea + "): " + filteredContours.size());
        filteredContours.sort((a, b) -> Double.compare(Imgproc.contourArea(b), Imgproc.contourArea(a)));
        Log.d("CannyDebug", "Filtered contours3: " + filteredContours.size());
        Bitmap contourBmp = drawContoursOnBitmap(bitmap, filteredContours);
        Log.d("CannyDebug", "Filtered contours4: " + filteredContours.size());
        debugSteps.add(contourBmp);

        MatOfPoint2f biggestQuad = null;
        double maxArea = -1;

        for (MatOfPoint c : filteredContours) {
            MatOfPoint2f approx = new MatOfPoint2f();
            Imgproc.approxPolyDP(new MatOfPoint2f(c.toArray()), approx, 0.02 * Imgproc.arcLength(new MatOfPoint2f(c.toArray()), true), true);
            if (approx.total() >= 4) {
                double area = Imgproc.contourArea(c);
                if (area > maxArea) {
                    maxArea = area;
                    biggestQuad = approx;
                }
            }
            Log.d("CannyDebug", "Filtered contours5: " + filteredContours.size());

        }

        Bitmap cropped = null;
        if (biggestQuad != null) {
            cropped = warpPerspective(bitmap, biggestQuad);
            if (cropped != null) {
                debugSteps.add(cropped);
            }
        }

        if (cropped != null) {
            return restoreImageSharpness(cropped);
        }

        // üß™ N·∫øu retry r·ªìi m√† v·∫´n kh√¥ng c√≥ contour ‚Üí th·ª≠ boost t∆∞∆°ng ph·∫£n
        if (filteredContours.size() == 0 && retryMode) {
            Log.d("CannyDebug", "üß™ Boost contrast v√¨ retryMode v·∫´n fail ‚Üí Th·ª≠ t·ª± tƒÉng t∆∞∆°ng ph·∫£n");

            Mat contrasted = new Mat();
            src.convertTo(contrasted, -1, 1.8, -40);  // TƒÉng t∆∞∆°ng ph·∫£n

            Mat edge2 = new Mat();
            Imgproc.Canny(contrasted, edge2, lower, upper);

            List<MatOfPoint> tempContours = new ArrayList<>();
            Imgproc.findContours(edge2, tempContours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);

            double minAreaBoost = (bitmap.getWidth() * bitmap.getHeight()) * 0.0025;
            for (MatOfPoint c : tempContours) {
                double area = Imgproc.contourArea(c);
                if (area > minAreaBoost) {
                    filteredContours.add(c);
                }
            }

            if (filteredContours.size() > 0) {
                debugSteps.add(drawContoursOnBitmap(bitmap, filteredContours));
                Log.d("CannyDebug", "‚úÖ Boost contrast th√†nh c√¥ng ‚Äî t√¨m th·∫•y " + filteredContours.size() + " contour!");
            } else {
                Log.d("CannyDebug", "‚ùå Boost contrast c≈©ng kh√¥ng gi√∫p ƒë∆∞·ª£c.");
            }
        }
        // üìå N·∫øu boost contrast v·∫´n kh√¥ng c√≥ g√¨ ‚Äî fallback crop ·ªü gi·ªØa ·∫£nh
        if (filteredContours.size() == 0) {
            Log.d("CannyDebug", "üìå Kh√¥ng t√¨m th·∫•y contour ‚Äî fallback crop gi·ªØa ·∫£nh");

            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            int margin = Math.min(w, h) / 10;

            Bitmap fallbackCrop = Bitmap.createBitmap(bitmap, margin, margin, w - 2 * margin, h - 2 * margin);
            debugSteps.add(fallbackCrop);

            Toast.makeText(context, "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c t√†i li·ªáu. ƒê√£ crop ·ªü gi·ªØa ·∫£nh.", Toast.LENGTH_SHORT).show();

            return restoreImageSharpness(fallbackCrop);
        }
        if (filteredContours.size() == 0) {
            Toast.makeText(context, "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c t√†i li·ªáu. Vui l√≤ng ƒë∆∞a ·∫£nh g·∫ßn h∆°n, r√µ vi·ªÅn h∆°n.", Toast.LENGTH_LONG).show();
            return null;
        }

        return null;
    }


    // Restoring sharpness of the cropped image after processing
    private static Bitmap restoreImageSharpness(Bitmap bitmap) {
        // Apply sharpening
        Bitmap restoredBitmap = sharpenImage(bitmap);
        return restoredBitmap;
    }

    // A simple method to sharpen the image
    private static Bitmap sharpenImage(Bitmap bitmap) {
        Bitmap sharpened = bitmap.copy(Bitmap.Config.ARGB_8888, true);
        Canvas canvas = new Canvas(sharpened);
        Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);

        // Create a sharpen matrix
        ColorMatrix sharpenMatrix = new ColorMatrix();
        sharpenMatrix.setSaturation(1.5f); // Adjust as needed

        paint.setColorFilter(new ColorMatrixColorFilter(sharpenMatrix));

        // Apply the sharpening to the enhanced image
        canvas.drawBitmap(bitmap, 0, 0, paint);

        return sharpened;
    }


    private static double computeMedian(Mat gray) {
        Mat flat = gray.reshape(0, 1);  // l√†m ph·∫≥ng th√†nh 1 h√†ng
        int total = (int) flat.total();
        byte[] data = new byte[total];
        flat.get(0, 0, data);
        int[] values = new int[total];
        for (int i = 0; i < total; i++) values[i] = data[i] & 0xFF; // ƒê∆∞a v·ªÅ m·∫£ng 1 chi·ªÅu
//        D√πng 0xFF? V√¨ byte trong Java c√≥ th·ªÉ √¢m (t·ª´ -128 ƒë·∫øn 127)
//        Nh∆∞ng gi√° tr·ªã pixel lu√¥n l√† unsigned t·ª´ 0 ‚Üí 255
//                & 0xFF s·∫Ω chuy·ªÉn byte √¢m ‚Üí int d∆∞∆°ng t∆∞∆°ng ·ª©ng
//        V√≠ d·ª•: -1 (byte) ‚Üí 255 (int)
//        ‚û°Ô∏è ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng ƒë·ªÉ chu·∫©n h√≥a d·ªØ li·ªáu!
        java.util.Arrays.sort(values);
        return values[total / 2]; //T√≠nh gi√° tr·ªã trung v·ªã (median) s√°ng
    }

private static Point[] reorderPoints(Point[] pts) {
    Point[] ordered = new Point[4];

    // T√≠nh t·ªïng (x+y) v√† hi·ªáu (y-x)
    List<Point> points = Arrays.asList(pts);

    ordered[0] = Collections.min(points, Comparator.comparingDouble(p -> p.x + p.y)); // Tr√°i tr√™n
    ordered[2] = Collections.max(points, Comparator.comparingDouble(p -> p.x + p.y)); // Ph·∫£i d∆∞·ªõi

    ordered[1] = Collections.min(points, Comparator.comparingDouble(p -> p.y - p.x)); // Ph·∫£i tr√™n
    ordered[3] = Collections.max(points, Comparator.comparingDouble(p -> p.y - p.x)); // Tr√°i d∆∞·ªõi

    return ordered;
}

    private static int indexOfMin(double[] arr) { // T√¨m v·ªã tr√≠ c√≥ gi√° tr·ªã nh·ªè nh·∫•t trong m·∫£ng
        int minIdx = 0;
        for (int i = 1; i < arr.length; i++)
            if (arr[i] < arr[minIdx]) minIdx = i;
        return minIdx;
    }

    private static int indexOfMax(double[] arr) { // T√¨m v·ªã tr√≠ c√≥ gi√° tr·ªã l·ªõn nh·∫•t trong m·∫£ng
        int maxIdx = 0;
        for (int i = 1; i < arr.length; i++)
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        return maxIdx;
    }
    private static Bitmap debugOrderedPoints(Bitmap bmp, Point[] points) {
        Bitmap bmpCopy = bmp.copy(Bitmap.Config.ARGB_8888, true);
        Canvas canvas = new Canvas(bmpCopy);
        Paint paint = new Paint();
        paint.setColor(Color.YELLOW);
        paint.setTextSize(40);

        for (int i = 0; i < points.length; i++) {
            canvas.drawText("P" + i, (float) points[i].x, (float) points[i].y, paint);
        }
        return bmpCopy;
    }

    private static Bitmap warpPerspective(Bitmap bitmap, MatOfPoint2f points) {//T·ª´ 1 ·∫£nh g·ªëc
        // + 4 ƒë·ªânh (t√†i li·ªáu ƒë√£ ph√°t hi·ªán), ta bi·∫øn ƒë·ªïi ph·ªëi c·∫£nh ƒë·ªÉ c·∫Øt, xoay, v√† du·ªói ph·∫≥ng t·ªù gi·∫•y ‚Üí gi·ªëng nh∆∞ scan.

        //üìå Chuy·ªÉn MatOfPoint2f sang m·∫£ng Point[]
        Point[] pts = points.toArray();
        Point[] ordered = reorderPoints(pts); //G·ªçi h√†m reorderPoints ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng th·ª© t·ª± g√≥c
        debugSteps.add(debugOrderedPoints(bitmap, ordered)); // Th√™m ·∫£nh debug n√†y
        MatOfPoint2f src = new MatOfPoint2f(ordered); //üìå T·∫°o ma tr·∫≠n ƒëi·ªÉm ngu·ªìn t·ª´ ·∫£nh g·ªëc (4 ƒëi·ªÉm c·ªßa t√†i li·ªáu)

//        //T·∫°o ma tr·∫≠n ƒëi·ªÉm ƒë√≠ch (chu·∫©n h√¨nh ch·ªØ nh·∫≠t) ‚Üí k√≠ch th∆∞·ªõc ·∫£nh ƒë√≠ch: 800 x 1000
//        MatOfPoint2f dst = new MatOfPoint2f(
//                new Point(0, 0), // G√≥c tr√™n b√™n tr√°i trong ·∫£nh k·∫øt qu·∫£
//                new Point(800, 0), // G√≥c tr√™n b√™n ph·∫£i ‚Üí ngang 800 pixels
//                new Point(800, 1000), // G√≥c d∆∞·ªõi b√™n ph·∫£i ‚Üí cao 1000 pixels, ngang 800 pixels
//                new Point(0, 1000) //G√≥c d∆∞·ªõi b√™n tr√°i ‚Üí cao 1000 pixels
//        );//==> ƒê√¢y l√† c√°ch ‚Äúdu·ªói ph·∫≥ng‚Äù ·∫£nh t√†i li·ªáu b·∫±ng c√°ch √©p n√≥ v√†o khung vu√¥ng chu·∫©n
//        //        üìå T·∫°o ·∫£nh k·∫øt qu·∫£ v·ªõi k√≠ch th∆∞·ªõc ƒë√≠ch (1000px cao, 800px r·ªông)
////        D√πng CV_8UC4 ƒë·ªÉ gi·ªØ 3 k√™nh m√†u (RGB)
//        Mat outputMat = new Mat(1000, 800, CvType.CV_8UC4);
        // ƒêO·∫†N TH√äM T√ç N·ªÆA C√íN CHECK
        // üìå T√≠nh k√≠ch th∆∞·ªõc t√†i li·ªáu th·ª±c t·∫ø d·ª±a tr√™n kho·∫£ng c√°ch gi·ªØa c√°c ƒëi·ªÉm ƒë√£ s·∫Øp x·∫øp
        double widthA = Math.hypot(ordered[2].x - ordered[3].x, ordered[2].y - ordered[3].y);
        double widthB = Math.hypot(ordered[1].x - ordered[0].x, ordered[1].y - ordered[0].y);
        double maxWidth = Math.max(widthA, widthB); // Chi·ªÅu ngang l·ªõn nh·∫•t

        double heightA = Math.hypot(ordered[1].x - ordered[2].x, ordered[1].y - ordered[2].y);
        double heightB = Math.hypot(ordered[0].x - ordered[3].x, ordered[0].y - ordered[3].y);
        double maxHeight = Math.max(heightA, heightB); // Chi·ªÅu d·ªçc l·ªõn nh·∫•t

// üìå T·∫°o ma tr·∫≠n ƒëi·ªÉm ƒë√≠ch (khung ch·ªØ nh·∫≠t chu·∫©n theo k√≠ch th∆∞·ªõc ƒë·ªông)
        MatOfPoint2f dst = new MatOfPoint2f(
                new Point(0, 0),
                new Point(maxWidth, 0),
                new Point(maxWidth, maxHeight),
                new Point(0, maxHeight)
        );

// üìå T·∫°o ·∫£nh ƒë·∫ßu ra ƒë√∫ng v·ªõi k√≠ch th∆∞·ªõc th·∫≠t
        Mat outputMat = new Mat((int) maxHeight, (int) maxWidth, CvType.CV_8UC4);
        //Chuy·ªÉn Bitmap ·∫£nh g·ªëc th√†nh Mat ƒë·ªÉ OpenCV x·ª≠ l√Ω
        Mat srcMat = new Mat();
        Utils.bitmapToMat(bitmap, srcMat);
//        üìå T√≠nh ma tr·∫≠n bi·∫øn ƒë·ªïi ph·ªëi c·∫£nh
//        src l√† 4 ƒëi·ªÉm th·ª±c t·∫ø tr√™n ·∫£nh g·ªëc
//        dst l√† khung ch·ªØ nh·∫≠t chu·∫©n
        Mat transform = Imgproc.getPerspectiveTransform(src, dst); //==> ma tr·∫≠n gi√∫p ‚Äúu·ªën cong‚Äù ho·∫∑c ‚Äún·∫Øn th·∫≥ng‚Äù ·∫£nh g·ªëc ‚Üí kh·ªõp v·ªõi khung chu·∫©n

//        üìå D√πng ma tr·∫≠n transform ƒë·ªÉ bi·∫øn ƒë·ªïi ·∫£nh
//        ·∫¢nh ƒë·∫ßu ra s·∫Ω l√† t√†i li·ªáu ƒë∆∞·ª£c c·∫Øt ƒë√∫ng khung + du·ªói ph·∫≥ng
        Imgproc.warpPerspective(srcMat, outputMat, transform, outputMat.size());
//        üìå Chuy·ªÉn ·∫£nh k·∫øt qu·∫£ t·ª´ Mat ‚Üí Bitmap ƒë·ªÉ hi·ªÉn th·ªã ho·∫∑c l∆∞u
//        Tr·∫£ v·ªÅ ·∫£nh ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
        Bitmap out = Bitmap.createBitmap(outputMat.cols(), outputMat.rows(), Bitmap.Config.ARGB_8888);
        Utils.matToBitmap(outputMat, out);
        return out;
    }

    public static Bitmap drawContoursOnBitmap(Bitmap baseBitmap, List<MatOfPoint> contours) { // M·ª•c ƒë√≠ch: nh·∫≠n v√†o m·ªôt ·∫£nh g·ªëc + danh s√°ch contour ‚Üí v·∫Ω t·ª´ng contour l√™n ·∫£nh, t√¥ m√†u:
        // T·∫°o b·∫£n sao c·ªßa ·∫£nh g·ªëc ƒë·ªÉ v·∫Ω l√™n
        Bitmap bmpWithContours = baseBitmap.copy(Bitmap.Config.ARGB_8888, true);
        Canvas canvas = new Canvas(bmpWithContours); // √ù nghƒ©a: Kh√¥ng v·∫Ω tr·ª±c ti·∫øp l√™n ·∫£nh g·ªëc, t·∫°o 1 Canvas ƒë·ªÉ v·∫Ω 1 API c·ªßa Android

        //Chu·∫©n b·ªã c·ªç v·∫Ω (Paint)
        Paint paint = new Paint();
        paint.setStrokeWidth(4); // Vi·ªÅn d√†y 4px
        paint.setStyle(Paint.Style.STROKE);

        //D√πng ƒë·ªÉ vi·∫øt ch·ªØ ghi s·ªë th·ª© t·ª± v√† di·ªán t√≠ch c·ªßa contour
        Paint textPaint = new Paint();
        textPaint.setColor(Color.BLUE);
        textPaint.setTextSize(18f);
        textPaint.setTypeface(Typeface.DEFAULT_BOLD);

        //Duy·ªát qua t·ª´ng contour
        for (int i = 0; i < contours.size(); i++) {
            MatOfPoint contour = contours.get(i);
            Point[] points = contour.toArray();

            // ‚úÖ Ki·ªÉm tra s·ªë ƒë·ªânh b·∫±ng approxPolyDP nh·∫±m x√°c ƒë·ªãnh ƒë∆∞·ª£c s·ªë ƒë·ªânh th·∫≠t
            MatOfPoint2f contour2f = new MatOfPoint2f(contour.toArray());
            double peri = Imgproc.arcLength(contour2f, true);
            MatOfPoint2f approx = new MatOfPoint2f();
            Imgproc.approxPolyDP(contour2f, approx, 0.08 * peri, true);
            int vertexCount = (int) approx.total(); // s·ªë ƒë·ªânh th·ª±c s·ª±
            //√ù nghƒ©a:
            //gi√∫p ƒë∆°n gi·∫£n h√≥a contour ‚Üí ƒë·∫øm ƒë∆∞·ª£c s·ªë ƒë·ªânh

            // T·∫°o m·ªôt ƒë∆∞·ªùng vi·ªÅn kh√©p k√≠n t·ª´ c√°c ƒëi·ªÉm contour
            // Android kh√¥ng c√≥ s·∫µn h√†m v·∫Ω MatOfPoint, n√™n d√πng Path
            Path path = new Path();
            if (points.length > 0) {

                path.moveTo((float) points[0].x, (float) points[0].y);
                for (int j = 1; j < points.length; j++) {
                    path.lineTo((float) points[j].x, (float) points[j].y);
                }
                path.close();

                // ƒê·ªïi m√†u n·∫øu contour c√≥ 4 ƒë·ªânh (nghi ng·ªù l√† t√†i li·ªáu)
                //paint.setColor(points.length == 4 ? Color.GREEN : Color.RED);
                paint.setColor(vertexCount >= 4 ? Color.GREEN : Color.RED);
                canvas.drawPath(path, paint);

                // üéØ T√≠nh trung t√¢m ƒë·ªÉ ƒë·∫∑t text, T√≠nh t√¢m contour ‚Üí v·∫Ω ch·ªØ
                double centerX = 0, centerY = 0;
                for (Point p : points) {
                    centerX += p.x;
                    centerY += p.y;
                }
                centerX /= points.length;
                centerY /= points.length; // T√≠nh trung b√¨nh c·ªông c√°c t·ªça ƒë·ªô ƒëi·ªÉm ‚Üí ra v·ªã tr√≠ ch√≠nh gi·ªØa contour

                // üéØ Ghi text: s·ªë th·ª© t·ª± + di·ªán t√≠ch
                double area = Imgproc.contourArea(contour);
                String label = "#" + (i + 1) + " (area: " + (int) area + ")";
                canvas.drawText(label, (float) centerX, (float) centerY, textPaint);
            }
        }
        return bmpWithContours;
    }


//    public static void saveDebugImages(Context context, List<Bitmap> images) {
//        for (int i = 0; i < images.size(); i++) {
//            String filename = "step_" + (i + 1) + ".png";
//            File file = FileUtils.getNewImageFile(context, filename);
//            try (FileOutputStream out = new FileOutputStream(file)) {
//                images.get(i).compress(Bitmap.CompressFormat.PNG, 100, out);
//            } catch (IOException e) {
//                e.printStackTrace();
//            }
//        }
//    }



}


